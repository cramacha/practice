Chapter 4: Trees and Graphs

1. Given a directed graph, design an algorithm to find out whether or not there
   is a route between two nodes.

2. Given a sorted array (increasing order), write an algorithm to create a
   binary search tree with minimal height (i.e. the key to minimal height is to
   ensure that it is to balance it).
  
3. Given a binary tree, design an algorithm that creates lists of nodes, where
   each list contains nodes that are all at the same depth within the tree.

4. Implement a function to check if a binary tree is balanced.

5. Write a function to check if a binary tree is a BST.

6. Write an algorithm to find the "next" node (i.e. in-order successor) of a
   given BST.  You may assume that each node contains a pointer to its
   respective parent within the tree.

7. Given a list of projects and a list of dependencies (i.e. a list of pairs
   of projects, where the second project is dependent on the first projets),
   find the build order that will allow all of the projects to be built.  If
   there is no valid build order, return an error.

8. Implement a function to find the first common ancestor of two nodes in a
   binary tree.  Note: this is not necessarily a BST either.

9. A binary search tree was created by traversing through an array from left
   to right and inserting each element.  Given a binary search tree with
   distinct elements, print all possible arrays that could have led to the
   creation of this tree.

10. T1 and T2 are very large binary trees with T1 being much bigger than T2.
    Create an algorithm to determine if T2 is a substree of T1.

11. Implement a function that returns a random node from a tree.  All nodes
    should be equally likely to be chosen. 

12. You are given a binary tree in which each node contains an integer value
    (which may be positive or negative).  Design an algorithm to count the
    nunber of paths that sum to a given value.  The path does not need to start
    or end at a root or leaf, but it must go downwards (traveling only from
    parent nodes to children).  
